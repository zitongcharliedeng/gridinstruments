/**
 * Note History Visualizer â€” Top Panel
 *
 * Three-panel canvas strip rendered at 60fps:
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚  Staff notation (25%)  â”‚  Waterfall history (50%)  â”‚  Chord + MIDI (25%)â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 * Left panel: Treble clef staff, note heads at correct staff positions, ledger lines.
 * Center: Piano-roll waterfall â€” notes scroll rightâ†’left, colored by pitch class, fade over 3s.
 * Right: Large chord name, note list, MIDI device status.
 */

import { NOTE_COLORS, noteColor } from './note-colors';
import { detectChord } from './chord-detector';

interface ActiveNote {
  coordX: number;
  coordY: number;
  midiNote: number;
  startTime: number; // performance.now()
}

interface HistoryNote {
  coordX: number;
  coordY: number;
  midiNote: number;
  startTime: number;
  endTime: number;
}

export class NoteHistoryVisualizer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private width: number = 900;
  private height: number = 220;

  // State
  private activeNotes: Map<string, ActiveNote> = new Map();
  private history: HistoryNote[] = [];

  // History display window: 3 seconds visible
  private readonly HISTORY_WINDOW_MS = 3000;
  // Trim history older than this
  private readonly MAX_HISTORY_AGE_MS = 4000;

  // MIDI range for waterfall (C2â€“C7, MIDI 36â€“96)
  private readonly MIDI_MIN = 36;
  private readonly MIDI_MAX = 96;

  private animFrame: number | null = null;

  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('No canvas context');
    this.ctx = ctx;
    this.resize(canvas.offsetWidth || 900, canvas.offsetHeight || 220);
  }

  resize(width: number, height: number): void {
    const dpr = window.devicePixelRatio || 1;
    this.width = width;
    this.height = height;
    this.canvas.width = width * dpr;
    this.canvas.height = height * dpr;
    this.canvas.style.width = `${width}px`;
    this.canvas.style.height = `${height}px`;
    this.ctx.scale(dpr, dpr);
  }

  /** Call when a note starts (from keyboard or MIDI) */
  noteOn(coordX: number, coordY: number, midiNote: number): void {
    const key = `${coordX}_${coordY}`;
    this.activeNotes.set(key, { coordX, coordY, midiNote, startTime: performance.now() });
  }

  /** Call when a note ends */
  noteOff(coordX: number, coordY: number): void {
    const key = `${coordX}_${coordY}`;
    const note = this.activeNotes.get(key);
    if (note) {
      this.history.push({ ...note, endTime: performance.now() });
      this.activeNotes.delete(key);
    }
  }

  /** Update MIDI connection status */
  setMidiStatus(_status: 'unavailable' | 'no-devices' | 'connected', _deviceName: string = ''): void {
    // No-op: MIDI status is shown in the MIDI settings panel only
  }

  /** Clear all active notes (e.g. on blur / stop-all) */
  clearAll(): void {
    const now = performance.now();
    for (const note of this.activeNotes.values()) {
      this.history.push({ ...note, endTime: now });
    }
    this.activeNotes.clear();
  }

  /** Start the 60fps render loop */
  start(): void {
    if (this.animFrame !== null) return;
    const loop = () => {
      this.render();
      this.animFrame = requestAnimationFrame(loop);
    };
    this.animFrame = requestAnimationFrame(loop);
  }

  /** Stop the render loop */
  stop(): void {
    if (this.animFrame !== null) {
      cancelAnimationFrame(this.animFrame);
      this.animFrame = null;
    }
  }

  private render(): void {
    const now = performance.now();

    // Trim old history
    this.history = this.history.filter(n => now - n.endTime < this.MAX_HISTORY_AGE_MS);

    const { width, height } = this;
    const leftW = Math.floor(width * 0.23);
    const rightW = Math.floor(width * 0.27);
    const centerW = width - leftW - rightW;

    this.ctx.fillStyle = '#0d0d1a';
    this.ctx.fillRect(0, 0, width, height);

    // Dividers
    this.ctx.strokeStyle = '#2a2a4a';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(leftW, 0); this.ctx.lineTo(leftW, height);
    this.ctx.moveTo(leftW + centerW, 0); this.ctx.lineTo(leftW + centerW, height);
    this.ctx.stroke();

    this.drawStaff(0, leftW, height, now);
    this.drawWaterfall(leftW, centerW, height, now);
    this.drawChordPanel(leftW + centerW, rightW, height, now);
  }

  // â”€â”€â”€ LEFT: Staff notation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private drawStaff(x: number, w: number, h: number, _now: number): void {
    const ctx = this.ctx;
    const padX = 18;
    const padY = 16;

    // Staff lines (treble clef: E4â€“F5 = 5 lines)
    // We draw 5 lines + 3 ledger extensions
    const lineCount = 5;
    const staffH = h - padY * 2 - 20;
    const lineSpacing = staffH / (lineCount + 3); // a bit extra for ledger lines
    const staffTop = padY + lineSpacing * 1.5; // offset down to allow ledger lines above

    ctx.strokeStyle = '#444466';
    ctx.lineWidth = 1;
    for (let l = 0; l < lineCount; l++) {
      const ly = staffTop + l * lineSpacing;
      ctx.beginPath();
      ctx.moveTo(x + padX, ly);
      ctx.lineTo(x + w - padX, ly);
      ctx.stroke();
    }

    // Draw treble clef symbol (simplified: just label)
    ctx.fillStyle = '#666688';
    ctx.font = 'bold 11px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğ„', x + padX / 2 + 3, staffTop + lineSpacing * 2);

    // Collect notes to display (active + recently ended within 1s)
    const now = performance.now();
    const allNotes: number[] = [];
    for (const n of this.activeNotes.values()) allNotes.push(n.midiNote);
    for (const n of this.history) {
      if (now - n.endTime < 1000) allNotes.push(n.midiNote);
    }

    if (allNotes.length === 0) {
      ctx.fillStyle = '#333355';
      ctx.font = '10px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('play a note', x + w / 2, h / 2);
      return;
    }

    // Draw note heads
    // Staff mapping: treble clef B4=line0 top, G4=line2, E4=line4 bottom
    // MIDI: B4=71, G4=67, E4=64, C4=60
    // We map MIDI note â†’ staff position (diatonic steps from B4 downward)
    for (const midi of [...new Set(allNotes)]) {
      const staffPos = this.midiToStaffPos(midi); // 0=top line, positive=down
      const ny = staffTop + staffPos * (lineSpacing / 2);

      if (ny < padY / 2 || ny > h - padY / 2) continue;

      const pc = ((midi % 12) + 12) % 12;
      const color = NOTE_COLORS[pc];
      const isActive = [...this.activeNotes.values()].some(n => n.midiNote === midi);
      const r = lineSpacing * 0.42;

      // Ledger lines if needed
      const lineIdxFloat = (ny - staffTop) / lineSpacing;
      if (lineIdxFloat < -0.25) {
        // Ledger lines above staff
        const topLine = staffTop;
        let ly = topLine - lineSpacing;
        while (ly > ny - lineSpacing * 0.1) {
          ctx.strokeStyle = '#444466';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + padX * 1.5, ly);
          ctx.lineTo(x + w - padX * 1.5, ly);
          ctx.stroke();
          ly -= lineSpacing;
        }
      } else if (lineIdxFloat > lineCount - 0.75) {
        // Ledger lines below staff
        const bottomLine = staffTop + (lineCount - 1) * lineSpacing;
        let ly = bottomLine + lineSpacing;
        while (ly < ny + lineSpacing * 0.1) {
          ctx.strokeStyle = '#444466';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + padX * 1.5, ly);
          ctx.lineTo(x + w - padX * 1.5, ly);
          ctx.stroke();
          ly += lineSpacing;
        }
      }

      // Note head (ellipse)
      ctx.beginPath();
      ctx.ellipse(x + w / 2, ny, r * 1.3, r * 0.85, -0.3, 0, Math.PI * 2);
      ctx.fillStyle = isActive ? color : color + '99';
      ctx.fill();
      if (isActive) {
        ctx.strokeStyle = '#ffffff44';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Note name label
      const noteName = this.midiToNoteName(midi);
      ctx.fillStyle = isActive ? '#ffffff' : '#aaaacc';
      ctx.font = `bold ${Math.max(8, r * 0.9)}px Inter, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(noteName, x + w / 2, ny);
    }
  }

  /** Map MIDI note to staff position. 0=B4 line, each step = semidiatonic. */
  private midiToStaffPos(midi: number): number {
    // Diatonic steps from B4 (MIDI 71) downward â†’ staff position increases
    // Treble staff: B4(0), A4(1), G4(2), F4(3), E4(4), D4(5), C4(6), B3(7)â€¦
    const diatonicFromB4 = [0, 0, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6]; // pitch class â†’ diatonic step offset
    const octaveDiatonic = 7;
    const b4Midi = 71;
    const diff = b4Midi - midi;
    const octave = Math.floor(diff / 12);
    const pc = ((midi % 12) + 12) % 12;
    // Position relative to B of that octave
    const diatonicOffset = diatonicFromB4[pc];
    // B is always step 0 in its octave; C is 6 steps above B in diatonic
    const pcDiatonic = diatonicOffset;
    return octave * octaveDiatonic + pcDiatonic;
  }

  private midiToNoteName(midi: number): string {
    const names = ['C','C#','D','Eb','E','F','F#','G','Ab','A','Bb','B'];
    return names[((midi % 12) + 12) % 12];
  }

  // â”€â”€â”€ CENTER: Waterfall â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private drawWaterfall(x: number, w: number, h: number, now: number): void {
    const ctx = this.ctx;
    const pad = 8;

    // Background
    ctx.fillStyle = '#0a0a18';
    ctx.fillRect(x, 0, w, h);

    // Empty state
    if (this.history.length === 0 && this.activeNotes.size === 0) {
      ctx.fillStyle = '#444';
      ctx.font = '12px JetBrains Mono, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Play some notes', x + w / 2, h / 2);
      return;
    }

    const midiRange = this.MIDI_MAX - this.MIDI_MIN;
    const noteH = (h - pad * 2) / midiRange;

    const midiToY = (midi: number) => {
      const clamped = Math.max(this.MIDI_MIN, Math.min(this.MIDI_MAX, midi));
      return pad + (this.MIDI_MAX - clamped) * noteH;
    };

    const timeToX = (t: number) => {
      // rightmost = now, leftmost = now - HISTORY_WINDOW_MS
      const age = now - t;
      return x + w - (age / this.HISTORY_WINDOW_MS) * w;
    };

    // Draw history notes
    for (const note of this.history) {
      const age = now - note.endTime;
      if (age > this.HISTORY_WINDOW_MS) continue;
      const alpha = Math.max(0, 1 - age / this.HISTORY_WINDOW_MS);

      const nx = timeToX(note.startTime);
      const ex = timeToX(note.endTime);
      const ny = midiToY(note.midiNote);
      const bw = Math.max(2, ex - nx);

      ctx.fillStyle = noteColor(note.midiNote, alpha * 0.65);
      ctx.fillRect(nx, ny, bw, Math.max(2, noteH - 1));
    }

    // Draw active notes (extends to now)
    for (const note of this.activeNotes.values()) {
      const nx = timeToX(note.startTime);
      const ny = midiToY(note.midiNote);
      const bw = Math.max(4, x + w - nx);

      ctx.fillStyle = noteColor(note.midiNote, 1.0);
      ctx.fillRect(nx, ny, bw, Math.max(2, noteH - 1));

      // Note name inside bar (if wide enough)
      if (bw > 20) {
        const noteName = this.midiToNoteName(note.midiNote);
        ctx.fillStyle = '#ffffffcc';
        ctx.font = `bold ${Math.max(9, noteH * 0.75)}px Inter, sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(noteName, Math.max(nx + 2, x + 2), ny + noteH / 2);
      }
    }

    // Time ruler: subtle gridlines every 0.5s
    ctx.strokeStyle = '#222244';
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 4]);
    for (let t = 0; t <= this.HISTORY_WINDOW_MS; t += 500) {
      const gx = x + w - (t / this.HISTORY_WINDOW_MS) * w;
      ctx.beginPath();
      ctx.moveTo(gx, 0);
      ctx.lineTo(gx, h);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // "NOW" line
    ctx.strokeStyle = '#ffffff22';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + w - 1, 0);
    ctx.lineTo(x + w - 1, h);
    ctx.stroke();
  }

  private drawChordPanel(x: number, w: number, h: number, _now: number): void {
    const ctx = this.ctx;
    const pad = 12;

    // Collect active note coords for chord detection
    const activeCoords: Array<[number, number, number]> = [];
    for (const n of this.activeNotes.values()) {
      activeCoords.push([n.coordX, n.coordY, 0]);
    }

    // Large chord name
    const chords = detectChord(activeCoords);
    const chordText = chords.length > 0 ? chords[0] : '';

    const chordY = h * 0.22;
    if (chordText) {
      // Gradient: pick first note color
      const firstNote = [...this.activeNotes.values()][0];
      const chordColor = firstNote ? noteColor(firstNote.midiNote, 1) : '#6366f1';

      ctx.font = `bold ${Math.min(42, w * 0.28)}px Inter, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = chordColor;
      ctx.fillText(chordText, x + w / 2, chordY);

      // Alternate chord names
      if (chords.length > 1) {
        ctx.font = `${Math.min(14, w * 0.1)}px Inter, sans-serif`;
        ctx.fillStyle = '#666688';
        ctx.fillText(chords.slice(1, 3).join(' / '), x + w / 2, chordY + 28);
      }
    } else {
      ctx.font = `bold ${Math.min(28, w * 0.2)}px Inter, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#222244';
      ctx.fillText('â€”', x + w / 2, chordY);
    }

    // Active note names (sorted by pitch, stacked vertically)
    const noteNames: string[] = [];
    const sortedNotes = [...this.activeNotes.values()].sort((a, b) => b.midiNote - a.midiNote);
    for (const n of sortedNotes) {
      noteNames.push(this.midiToNoteName(n.midiNote) + (Math.floor(n.midiNote / 12) - 1));
    }

    const noteListY = h * 0.58;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const lineH = Math.min(18, (h - noteListY - pad) / Math.max(1, noteNames.length));

    for (let i = 0; i < noteNames.length && i < 8; i++) {
      const ny = noteListY + i * lineH;
      const midi = sortedNotes[i].midiNote;
      ctx.font = `${Math.min(14, lineH * 0.8)}px Inter, sans-serif`;
      ctx.fillStyle = noteColor(midi, 0.9);
      ctx.fillText(noteNames[i], x + w / 2, ny);
    }
  }
}
